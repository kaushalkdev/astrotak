// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'relatives_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$RelativesEventTearOff {
  const _$RelativesEventTearOff();

  GetRelatives getRelatives() {
    return const GetRelatives();
  }

  UpdateReltive updateRelative(Relative relative) {
    return UpdateReltive(
      relative,
    );
  }

  AddRelative addRelatives(Relative relative) {
    return AddRelative(
      relative,
    );
  }

  DeleteRelative deleteRelatives(String uuid) {
    return DeleteRelative(
      uuid,
    );
  }

  GetLocation getLocation(String location) {
    return GetLocation(
      location,
    );
  }
}

/// @nodoc
const $RelativesEvent = _$RelativesEventTearOff();

/// @nodoc
mixin _$RelativesEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getRelatives,
    required TResult Function(Relative relative) updateRelative,
    required TResult Function(Relative relative) addRelatives,
    required TResult Function(String uuid) deleteRelatives,
    required TResult Function(String location) getLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetRelatives value) getRelatives,
    required TResult Function(UpdateReltive value) updateRelative,
    required TResult Function(AddRelative value) addRelatives,
    required TResult Function(DeleteRelative value) deleteRelatives,
    required TResult Function(GetLocation value) getLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RelativesEventCopyWith<$Res> {
  factory $RelativesEventCopyWith(
          RelativesEvent value, $Res Function(RelativesEvent) then) =
      _$RelativesEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$RelativesEventCopyWithImpl<$Res>
    implements $RelativesEventCopyWith<$Res> {
  _$RelativesEventCopyWithImpl(this._value, this._then);

  final RelativesEvent _value;
  // ignore: unused_field
  final $Res Function(RelativesEvent) _then;
}

/// @nodoc
abstract class $GetRelativesCopyWith<$Res> {
  factory $GetRelativesCopyWith(
          GetRelatives value, $Res Function(GetRelatives) then) =
      _$GetRelativesCopyWithImpl<$Res>;
}

/// @nodoc
class _$GetRelativesCopyWithImpl<$Res>
    extends _$RelativesEventCopyWithImpl<$Res>
    implements $GetRelativesCopyWith<$Res> {
  _$GetRelativesCopyWithImpl(
      GetRelatives _value, $Res Function(GetRelatives) _then)
      : super(_value, (v) => _then(v as GetRelatives));

  @override
  GetRelatives get _value => super._value as GetRelatives;
}

/// @nodoc

class _$GetRelatives implements GetRelatives {
  const _$GetRelatives();

  @override
  String toString() {
    return 'RelativesEvent.getRelatives()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is GetRelatives);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getRelatives,
    required TResult Function(Relative relative) updateRelative,
    required TResult Function(Relative relative) addRelatives,
    required TResult Function(String uuid) deleteRelatives,
    required TResult Function(String location) getLocation,
  }) {
    return getRelatives();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
  }) {
    return getRelatives?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
    required TResult orElse(),
  }) {
    if (getRelatives != null) {
      return getRelatives();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetRelatives value) getRelatives,
    required TResult Function(UpdateReltive value) updateRelative,
    required TResult Function(AddRelative value) addRelatives,
    required TResult Function(DeleteRelative value) deleteRelatives,
    required TResult Function(GetLocation value) getLocation,
  }) {
    return getRelatives(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
  }) {
    return getRelatives?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
    required TResult orElse(),
  }) {
    if (getRelatives != null) {
      return getRelatives(this);
    }
    return orElse();
  }
}

abstract class GetRelatives implements RelativesEvent {
  const factory GetRelatives() = _$GetRelatives;
}

/// @nodoc
abstract class $UpdateReltiveCopyWith<$Res> {
  factory $UpdateReltiveCopyWith(
          UpdateReltive value, $Res Function(UpdateReltive) then) =
      _$UpdateReltiveCopyWithImpl<$Res>;
  $Res call({Relative relative});
}

/// @nodoc
class _$UpdateReltiveCopyWithImpl<$Res>
    extends _$RelativesEventCopyWithImpl<$Res>
    implements $UpdateReltiveCopyWith<$Res> {
  _$UpdateReltiveCopyWithImpl(
      UpdateReltive _value, $Res Function(UpdateReltive) _then)
      : super(_value, (v) => _then(v as UpdateReltive));

  @override
  UpdateReltive get _value => super._value as UpdateReltive;

  @override
  $Res call({
    Object? relative = freezed,
  }) {
    return _then(UpdateReltive(
      relative == freezed
          ? _value.relative
          : relative // ignore: cast_nullable_to_non_nullable
              as Relative,
    ));
  }
}

/// @nodoc

class _$UpdateReltive implements UpdateReltive {
  const _$UpdateReltive(this.relative);

  @override
  final Relative relative;

  @override
  String toString() {
    return 'RelativesEvent.updateRelative(relative: $relative)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UpdateReltive &&
            const DeepCollectionEquality().equals(other.relative, relative));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(relative));

  @JsonKey(ignore: true)
  @override
  $UpdateReltiveCopyWith<UpdateReltive> get copyWith =>
      _$UpdateReltiveCopyWithImpl<UpdateReltive>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getRelatives,
    required TResult Function(Relative relative) updateRelative,
    required TResult Function(Relative relative) addRelatives,
    required TResult Function(String uuid) deleteRelatives,
    required TResult Function(String location) getLocation,
  }) {
    return updateRelative(relative);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
  }) {
    return updateRelative?.call(relative);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
    required TResult orElse(),
  }) {
    if (updateRelative != null) {
      return updateRelative(relative);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetRelatives value) getRelatives,
    required TResult Function(UpdateReltive value) updateRelative,
    required TResult Function(AddRelative value) addRelatives,
    required TResult Function(DeleteRelative value) deleteRelatives,
    required TResult Function(GetLocation value) getLocation,
  }) {
    return updateRelative(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
  }) {
    return updateRelative?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
    required TResult orElse(),
  }) {
    if (updateRelative != null) {
      return updateRelative(this);
    }
    return orElse();
  }
}

abstract class UpdateReltive implements RelativesEvent {
  const factory UpdateReltive(Relative relative) = _$UpdateReltive;

  Relative get relative;
  @JsonKey(ignore: true)
  $UpdateReltiveCopyWith<UpdateReltive> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddRelativeCopyWith<$Res> {
  factory $AddRelativeCopyWith(
          AddRelative value, $Res Function(AddRelative) then) =
      _$AddRelativeCopyWithImpl<$Res>;
  $Res call({Relative relative});
}

/// @nodoc
class _$AddRelativeCopyWithImpl<$Res> extends _$RelativesEventCopyWithImpl<$Res>
    implements $AddRelativeCopyWith<$Res> {
  _$AddRelativeCopyWithImpl(
      AddRelative _value, $Res Function(AddRelative) _then)
      : super(_value, (v) => _then(v as AddRelative));

  @override
  AddRelative get _value => super._value as AddRelative;

  @override
  $Res call({
    Object? relative = freezed,
  }) {
    return _then(AddRelative(
      relative == freezed
          ? _value.relative
          : relative // ignore: cast_nullable_to_non_nullable
              as Relative,
    ));
  }
}

/// @nodoc

class _$AddRelative implements AddRelative {
  const _$AddRelative(this.relative);

  @override
  final Relative relative;

  @override
  String toString() {
    return 'RelativesEvent.addRelatives(relative: $relative)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AddRelative &&
            const DeepCollectionEquality().equals(other.relative, relative));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(relative));

  @JsonKey(ignore: true)
  @override
  $AddRelativeCopyWith<AddRelative> get copyWith =>
      _$AddRelativeCopyWithImpl<AddRelative>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getRelatives,
    required TResult Function(Relative relative) updateRelative,
    required TResult Function(Relative relative) addRelatives,
    required TResult Function(String uuid) deleteRelatives,
    required TResult Function(String location) getLocation,
  }) {
    return addRelatives(relative);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
  }) {
    return addRelatives?.call(relative);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
    required TResult orElse(),
  }) {
    if (addRelatives != null) {
      return addRelatives(relative);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetRelatives value) getRelatives,
    required TResult Function(UpdateReltive value) updateRelative,
    required TResult Function(AddRelative value) addRelatives,
    required TResult Function(DeleteRelative value) deleteRelatives,
    required TResult Function(GetLocation value) getLocation,
  }) {
    return addRelatives(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
  }) {
    return addRelatives?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
    required TResult orElse(),
  }) {
    if (addRelatives != null) {
      return addRelatives(this);
    }
    return orElse();
  }
}

abstract class AddRelative implements RelativesEvent {
  const factory AddRelative(Relative relative) = _$AddRelative;

  Relative get relative;
  @JsonKey(ignore: true)
  $AddRelativeCopyWith<AddRelative> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteRelativeCopyWith<$Res> {
  factory $DeleteRelativeCopyWith(
          DeleteRelative value, $Res Function(DeleteRelative) then) =
      _$DeleteRelativeCopyWithImpl<$Res>;
  $Res call({String uuid});
}

/// @nodoc
class _$DeleteRelativeCopyWithImpl<$Res>
    extends _$RelativesEventCopyWithImpl<$Res>
    implements $DeleteRelativeCopyWith<$Res> {
  _$DeleteRelativeCopyWithImpl(
      DeleteRelative _value, $Res Function(DeleteRelative) _then)
      : super(_value, (v) => _then(v as DeleteRelative));

  @override
  DeleteRelative get _value => super._value as DeleteRelative;

  @override
  $Res call({
    Object? uuid = freezed,
  }) {
    return _then(DeleteRelative(
      uuid == freezed
          ? _value.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DeleteRelative implements DeleteRelative {
  const _$DeleteRelative(this.uuid);

  @override
  final String uuid;

  @override
  String toString() {
    return 'RelativesEvent.deleteRelatives(uuid: $uuid)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeleteRelative &&
            const DeepCollectionEquality().equals(other.uuid, uuid));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(uuid));

  @JsonKey(ignore: true)
  @override
  $DeleteRelativeCopyWith<DeleteRelative> get copyWith =>
      _$DeleteRelativeCopyWithImpl<DeleteRelative>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getRelatives,
    required TResult Function(Relative relative) updateRelative,
    required TResult Function(Relative relative) addRelatives,
    required TResult Function(String uuid) deleteRelatives,
    required TResult Function(String location) getLocation,
  }) {
    return deleteRelatives(uuid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
  }) {
    return deleteRelatives?.call(uuid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
    required TResult orElse(),
  }) {
    if (deleteRelatives != null) {
      return deleteRelatives(uuid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetRelatives value) getRelatives,
    required TResult Function(UpdateReltive value) updateRelative,
    required TResult Function(AddRelative value) addRelatives,
    required TResult Function(DeleteRelative value) deleteRelatives,
    required TResult Function(GetLocation value) getLocation,
  }) {
    return deleteRelatives(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
  }) {
    return deleteRelatives?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
    required TResult orElse(),
  }) {
    if (deleteRelatives != null) {
      return deleteRelatives(this);
    }
    return orElse();
  }
}

abstract class DeleteRelative implements RelativesEvent {
  const factory DeleteRelative(String uuid) = _$DeleteRelative;

  String get uuid;
  @JsonKey(ignore: true)
  $DeleteRelativeCopyWith<DeleteRelative> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetLocationCopyWith<$Res> {
  factory $GetLocationCopyWith(
          GetLocation value, $Res Function(GetLocation) then) =
      _$GetLocationCopyWithImpl<$Res>;
  $Res call({String location});
}

/// @nodoc
class _$GetLocationCopyWithImpl<$Res> extends _$RelativesEventCopyWithImpl<$Res>
    implements $GetLocationCopyWith<$Res> {
  _$GetLocationCopyWithImpl(
      GetLocation _value, $Res Function(GetLocation) _then)
      : super(_value, (v) => _then(v as GetLocation));

  @override
  GetLocation get _value => super._value as GetLocation;

  @override
  $Res call({
    Object? location = freezed,
  }) {
    return _then(GetLocation(
      location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GetLocation implements GetLocation {
  const _$GetLocation(this.location);

  @override
  final String location;

  @override
  String toString() {
    return 'RelativesEvent.getLocation(location: $location)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is GetLocation &&
            const DeepCollectionEquality().equals(other.location, location));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(location));

  @JsonKey(ignore: true)
  @override
  $GetLocationCopyWith<GetLocation> get copyWith =>
      _$GetLocationCopyWithImpl<GetLocation>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getRelatives,
    required TResult Function(Relative relative) updateRelative,
    required TResult Function(Relative relative) addRelatives,
    required TResult Function(String uuid) deleteRelatives,
    required TResult Function(String location) getLocation,
  }) {
    return getLocation(location);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
  }) {
    return getLocation?.call(location);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getRelatives,
    TResult Function(Relative relative)? updateRelative,
    TResult Function(Relative relative)? addRelatives,
    TResult Function(String uuid)? deleteRelatives,
    TResult Function(String location)? getLocation,
    required TResult orElse(),
  }) {
    if (getLocation != null) {
      return getLocation(location);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetRelatives value) getRelatives,
    required TResult Function(UpdateReltive value) updateRelative,
    required TResult Function(AddRelative value) addRelatives,
    required TResult Function(DeleteRelative value) deleteRelatives,
    required TResult Function(GetLocation value) getLocation,
  }) {
    return getLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
  }) {
    return getLocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetRelatives value)? getRelatives,
    TResult Function(UpdateReltive value)? updateRelative,
    TResult Function(AddRelative value)? addRelatives,
    TResult Function(DeleteRelative value)? deleteRelatives,
    TResult Function(GetLocation value)? getLocation,
    required TResult orElse(),
  }) {
    if (getLocation != null) {
      return getLocation(this);
    }
    return orElse();
  }
}

abstract class GetLocation implements RelativesEvent {
  const factory GetLocation(String location) = _$GetLocation;

  String get location;
  @JsonKey(ignore: true)
  $GetLocationCopyWith<GetLocation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$RelativesStateTearOff {
  const _$RelativesStateTearOff();

  _Initial initial() {
    return const _Initial();
  }

  RelativesLoaded relativesLoaded(List<Relative> relatives) {
    return RelativesLoaded(
      relatives,
    );
  }

  RelativeUpdated relativeUpdated() {
    return const RelativeUpdated();
  }

  RelativeAdded relativeAdded() {
    return const RelativeAdded();
  }

  RelativeDeleted relativeDeleted() {
    return const RelativeDeleted();
  }

  LoationLoaded loationLoaded(List<Location> locations) {
    return LoationLoaded(
      locations,
    );
  }

  Error error(String message) {
    return Error(
      message,
    );
  }
}

/// @nodoc
const $RelativesState = _$RelativesStateTearOff();

/// @nodoc
mixin _$RelativesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<Relative> relatives) relativesLoaded,
    required TResult Function() relativeUpdated,
    required TResult Function() relativeAdded,
    required TResult Function() relativeDeleted,
    required TResult Function(List<Location> locations) loationLoaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(RelativesLoaded value) relativesLoaded,
    required TResult Function(RelativeUpdated value) relativeUpdated,
    required TResult Function(RelativeAdded value) relativeAdded,
    required TResult Function(RelativeDeleted value) relativeDeleted,
    required TResult Function(LoationLoaded value) loationLoaded,
    required TResult Function(Error value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RelativesStateCopyWith<$Res> {
  factory $RelativesStateCopyWith(
          RelativesState value, $Res Function(RelativesState) then) =
      _$RelativesStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$RelativesStateCopyWithImpl<$Res>
    implements $RelativesStateCopyWith<$Res> {
  _$RelativesStateCopyWithImpl(this._value, this._then);

  final RelativesState _value;
  // ignore: unused_field
  final $Res Function(RelativesState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res> extends _$RelativesStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'RelativesState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<Relative> relatives) relativesLoaded,
    required TResult Function() relativeUpdated,
    required TResult Function() relativeAdded,
    required TResult Function() relativeDeleted,
    required TResult Function(List<Location> locations) loationLoaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(RelativesLoaded value) relativesLoaded,
    required TResult Function(RelativeUpdated value) relativeUpdated,
    required TResult Function(RelativeAdded value) relativeAdded,
    required TResult Function(RelativeDeleted value) relativeDeleted,
    required TResult Function(LoationLoaded value) loationLoaded,
    required TResult Function(Error value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements RelativesState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class $RelativesLoadedCopyWith<$Res> {
  factory $RelativesLoadedCopyWith(
          RelativesLoaded value, $Res Function(RelativesLoaded) then) =
      _$RelativesLoadedCopyWithImpl<$Res>;
  $Res call({List<Relative> relatives});
}

/// @nodoc
class _$RelativesLoadedCopyWithImpl<$Res>
    extends _$RelativesStateCopyWithImpl<$Res>
    implements $RelativesLoadedCopyWith<$Res> {
  _$RelativesLoadedCopyWithImpl(
      RelativesLoaded _value, $Res Function(RelativesLoaded) _then)
      : super(_value, (v) => _then(v as RelativesLoaded));

  @override
  RelativesLoaded get _value => super._value as RelativesLoaded;

  @override
  $Res call({
    Object? relatives = freezed,
  }) {
    return _then(RelativesLoaded(
      relatives == freezed
          ? _value.relatives
          : relatives // ignore: cast_nullable_to_non_nullable
              as List<Relative>,
    ));
  }
}

/// @nodoc

class _$RelativesLoaded implements RelativesLoaded {
  const _$RelativesLoaded(this.relatives);

  @override
  final List<Relative> relatives;

  @override
  String toString() {
    return 'RelativesState.relativesLoaded(relatives: $relatives)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RelativesLoaded &&
            const DeepCollectionEquality().equals(other.relatives, relatives));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(relatives));

  @JsonKey(ignore: true)
  @override
  $RelativesLoadedCopyWith<RelativesLoaded> get copyWith =>
      _$RelativesLoadedCopyWithImpl<RelativesLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<Relative> relatives) relativesLoaded,
    required TResult Function() relativeUpdated,
    required TResult Function() relativeAdded,
    required TResult Function() relativeDeleted,
    required TResult Function(List<Location> locations) loationLoaded,
    required TResult Function(String message) error,
  }) {
    return relativesLoaded(relatives);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
  }) {
    return relativesLoaded?.call(relatives);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (relativesLoaded != null) {
      return relativesLoaded(relatives);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(RelativesLoaded value) relativesLoaded,
    required TResult Function(RelativeUpdated value) relativeUpdated,
    required TResult Function(RelativeAdded value) relativeAdded,
    required TResult Function(RelativeDeleted value) relativeDeleted,
    required TResult Function(LoationLoaded value) loationLoaded,
    required TResult Function(Error value) error,
  }) {
    return relativesLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
  }) {
    return relativesLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (relativesLoaded != null) {
      return relativesLoaded(this);
    }
    return orElse();
  }
}

abstract class RelativesLoaded implements RelativesState {
  const factory RelativesLoaded(List<Relative> relatives) = _$RelativesLoaded;

  List<Relative> get relatives;
  @JsonKey(ignore: true)
  $RelativesLoadedCopyWith<RelativesLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RelativeUpdatedCopyWith<$Res> {
  factory $RelativeUpdatedCopyWith(
          RelativeUpdated value, $Res Function(RelativeUpdated) then) =
      _$RelativeUpdatedCopyWithImpl<$Res>;
}

/// @nodoc
class _$RelativeUpdatedCopyWithImpl<$Res>
    extends _$RelativesStateCopyWithImpl<$Res>
    implements $RelativeUpdatedCopyWith<$Res> {
  _$RelativeUpdatedCopyWithImpl(
      RelativeUpdated _value, $Res Function(RelativeUpdated) _then)
      : super(_value, (v) => _then(v as RelativeUpdated));

  @override
  RelativeUpdated get _value => super._value as RelativeUpdated;
}

/// @nodoc

class _$RelativeUpdated implements RelativeUpdated {
  const _$RelativeUpdated();

  @override
  String toString() {
    return 'RelativesState.relativeUpdated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is RelativeUpdated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<Relative> relatives) relativesLoaded,
    required TResult Function() relativeUpdated,
    required TResult Function() relativeAdded,
    required TResult Function() relativeDeleted,
    required TResult Function(List<Location> locations) loationLoaded,
    required TResult Function(String message) error,
  }) {
    return relativeUpdated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
  }) {
    return relativeUpdated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (relativeUpdated != null) {
      return relativeUpdated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(RelativesLoaded value) relativesLoaded,
    required TResult Function(RelativeUpdated value) relativeUpdated,
    required TResult Function(RelativeAdded value) relativeAdded,
    required TResult Function(RelativeDeleted value) relativeDeleted,
    required TResult Function(LoationLoaded value) loationLoaded,
    required TResult Function(Error value) error,
  }) {
    return relativeUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
  }) {
    return relativeUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (relativeUpdated != null) {
      return relativeUpdated(this);
    }
    return orElse();
  }
}

abstract class RelativeUpdated implements RelativesState {
  const factory RelativeUpdated() = _$RelativeUpdated;
}

/// @nodoc
abstract class $RelativeAddedCopyWith<$Res> {
  factory $RelativeAddedCopyWith(
          RelativeAdded value, $Res Function(RelativeAdded) then) =
      _$RelativeAddedCopyWithImpl<$Res>;
}

/// @nodoc
class _$RelativeAddedCopyWithImpl<$Res>
    extends _$RelativesStateCopyWithImpl<$Res>
    implements $RelativeAddedCopyWith<$Res> {
  _$RelativeAddedCopyWithImpl(
      RelativeAdded _value, $Res Function(RelativeAdded) _then)
      : super(_value, (v) => _then(v as RelativeAdded));

  @override
  RelativeAdded get _value => super._value as RelativeAdded;
}

/// @nodoc

class _$RelativeAdded implements RelativeAdded {
  const _$RelativeAdded();

  @override
  String toString() {
    return 'RelativesState.relativeAdded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is RelativeAdded);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<Relative> relatives) relativesLoaded,
    required TResult Function() relativeUpdated,
    required TResult Function() relativeAdded,
    required TResult Function() relativeDeleted,
    required TResult Function(List<Location> locations) loationLoaded,
    required TResult Function(String message) error,
  }) {
    return relativeAdded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
  }) {
    return relativeAdded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (relativeAdded != null) {
      return relativeAdded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(RelativesLoaded value) relativesLoaded,
    required TResult Function(RelativeUpdated value) relativeUpdated,
    required TResult Function(RelativeAdded value) relativeAdded,
    required TResult Function(RelativeDeleted value) relativeDeleted,
    required TResult Function(LoationLoaded value) loationLoaded,
    required TResult Function(Error value) error,
  }) {
    return relativeAdded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
  }) {
    return relativeAdded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (relativeAdded != null) {
      return relativeAdded(this);
    }
    return orElse();
  }
}

abstract class RelativeAdded implements RelativesState {
  const factory RelativeAdded() = _$RelativeAdded;
}

/// @nodoc
abstract class $RelativeDeletedCopyWith<$Res> {
  factory $RelativeDeletedCopyWith(
          RelativeDeleted value, $Res Function(RelativeDeleted) then) =
      _$RelativeDeletedCopyWithImpl<$Res>;
}

/// @nodoc
class _$RelativeDeletedCopyWithImpl<$Res>
    extends _$RelativesStateCopyWithImpl<$Res>
    implements $RelativeDeletedCopyWith<$Res> {
  _$RelativeDeletedCopyWithImpl(
      RelativeDeleted _value, $Res Function(RelativeDeleted) _then)
      : super(_value, (v) => _then(v as RelativeDeleted));

  @override
  RelativeDeleted get _value => super._value as RelativeDeleted;
}

/// @nodoc

class _$RelativeDeleted implements RelativeDeleted {
  const _$RelativeDeleted();

  @override
  String toString() {
    return 'RelativesState.relativeDeleted()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is RelativeDeleted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<Relative> relatives) relativesLoaded,
    required TResult Function() relativeUpdated,
    required TResult Function() relativeAdded,
    required TResult Function() relativeDeleted,
    required TResult Function(List<Location> locations) loationLoaded,
    required TResult Function(String message) error,
  }) {
    return relativeDeleted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
  }) {
    return relativeDeleted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (relativeDeleted != null) {
      return relativeDeleted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(RelativesLoaded value) relativesLoaded,
    required TResult Function(RelativeUpdated value) relativeUpdated,
    required TResult Function(RelativeAdded value) relativeAdded,
    required TResult Function(RelativeDeleted value) relativeDeleted,
    required TResult Function(LoationLoaded value) loationLoaded,
    required TResult Function(Error value) error,
  }) {
    return relativeDeleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
  }) {
    return relativeDeleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (relativeDeleted != null) {
      return relativeDeleted(this);
    }
    return orElse();
  }
}

abstract class RelativeDeleted implements RelativesState {
  const factory RelativeDeleted() = _$RelativeDeleted;
}

/// @nodoc
abstract class $LoationLoadedCopyWith<$Res> {
  factory $LoationLoadedCopyWith(
          LoationLoaded value, $Res Function(LoationLoaded) then) =
      _$LoationLoadedCopyWithImpl<$Res>;
  $Res call({List<Location> locations});
}

/// @nodoc
class _$LoationLoadedCopyWithImpl<$Res>
    extends _$RelativesStateCopyWithImpl<$Res>
    implements $LoationLoadedCopyWith<$Res> {
  _$LoationLoadedCopyWithImpl(
      LoationLoaded _value, $Res Function(LoationLoaded) _then)
      : super(_value, (v) => _then(v as LoationLoaded));

  @override
  LoationLoaded get _value => super._value as LoationLoaded;

  @override
  $Res call({
    Object? locations = freezed,
  }) {
    return _then(LoationLoaded(
      locations == freezed
          ? _value.locations
          : locations // ignore: cast_nullable_to_non_nullable
              as List<Location>,
    ));
  }
}

/// @nodoc

class _$LoationLoaded implements LoationLoaded {
  const _$LoationLoaded(this.locations);

  @override
  final List<Location> locations;

  @override
  String toString() {
    return 'RelativesState.loationLoaded(locations: $locations)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is LoationLoaded &&
            const DeepCollectionEquality().equals(other.locations, locations));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(locations));

  @JsonKey(ignore: true)
  @override
  $LoationLoadedCopyWith<LoationLoaded> get copyWith =>
      _$LoationLoadedCopyWithImpl<LoationLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<Relative> relatives) relativesLoaded,
    required TResult Function() relativeUpdated,
    required TResult Function() relativeAdded,
    required TResult Function() relativeDeleted,
    required TResult Function(List<Location> locations) loationLoaded,
    required TResult Function(String message) error,
  }) {
    return loationLoaded(locations);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
  }) {
    return loationLoaded?.call(locations);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loationLoaded != null) {
      return loationLoaded(locations);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(RelativesLoaded value) relativesLoaded,
    required TResult Function(RelativeUpdated value) relativeUpdated,
    required TResult Function(RelativeAdded value) relativeAdded,
    required TResult Function(RelativeDeleted value) relativeDeleted,
    required TResult Function(LoationLoaded value) loationLoaded,
    required TResult Function(Error value) error,
  }) {
    return loationLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
  }) {
    return loationLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (loationLoaded != null) {
      return loationLoaded(this);
    }
    return orElse();
  }
}

abstract class LoationLoaded implements RelativesState {
  const factory LoationLoaded(List<Location> locations) = _$LoationLoaded;

  List<Location> get locations;
  @JsonKey(ignore: true)
  $LoationLoadedCopyWith<LoationLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ErrorCopyWith<$Res> {
  factory $ErrorCopyWith(Error value, $Res Function(Error) then) =
      _$ErrorCopyWithImpl<$Res>;
  $Res call({String message});
}

/// @nodoc
class _$ErrorCopyWithImpl<$Res> extends _$RelativesStateCopyWithImpl<$Res>
    implements $ErrorCopyWith<$Res> {
  _$ErrorCopyWithImpl(Error _value, $Res Function(Error) _then)
      : super(_value, (v) => _then(v as Error));

  @override
  Error get _value => super._value as Error;

  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(Error(
      message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Error implements Error {
  const _$Error(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'RelativesState.error(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Error &&
            const DeepCollectionEquality().equals(other.message, message));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(message));

  @JsonKey(ignore: true)
  @override
  $ErrorCopyWith<Error> get copyWith =>
      _$ErrorCopyWithImpl<Error>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(List<Relative> relatives) relativesLoaded,
    required TResult Function() relativeUpdated,
    required TResult Function() relativeAdded,
    required TResult Function() relativeDeleted,
    required TResult Function(List<Location> locations) loationLoaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(List<Relative> relatives)? relativesLoaded,
    TResult Function()? relativeUpdated,
    TResult Function()? relativeAdded,
    TResult Function()? relativeDeleted,
    TResult Function(List<Location> locations)? loationLoaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(RelativesLoaded value) relativesLoaded,
    required TResult Function(RelativeUpdated value) relativeUpdated,
    required TResult Function(RelativeAdded value) relativeAdded,
    required TResult Function(RelativeDeleted value) relativeDeleted,
    required TResult Function(LoationLoaded value) loationLoaded,
    required TResult Function(Error value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(RelativesLoaded value)? relativesLoaded,
    TResult Function(RelativeUpdated value)? relativeUpdated,
    TResult Function(RelativeAdded value)? relativeAdded,
    TResult Function(RelativeDeleted value)? relativeDeleted,
    TResult Function(LoationLoaded value)? loationLoaded,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class Error implements RelativesState {
  const factory Error(String message) = _$Error;

  String get message;
  @JsonKey(ignore: true)
  $ErrorCopyWith<Error> get copyWith => throw _privateConstructorUsedError;
}
